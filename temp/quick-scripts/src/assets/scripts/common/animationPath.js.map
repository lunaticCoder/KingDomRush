{"version":3,"sources":["assets/scripts/common/animationPath.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["//animationPath.ts\nconst { ccclass, property } = cc._decorator;\n\n// 贝塞尔曲线段类\nexport class BezierPart {\n    startPos: cc.Vec2;\n    cPos1: cc.Vec2;\n    cPos2: cc.Vec2;\n    endPos: cc.Vec2;\n    /**\n     * 将贝塞尔曲线分成多个点，不包含开始端点\n     */\n    posArray: cc.Vec2[] = [];\n    lenght: number = null;\n\n    /**\n     * 贝塞尔曲线段类\n     * @param startP 开始点坐标 \n     * @param cP1 控制点1\n     * @param cP2 控制点2\n     * @param endP 结束点\n     */\n    constructor(startP: cc.Vec2, cP1: cc.Vec2, cP2: cc.Vec2, endP: cc.Vec2) {\n        this.startPos = startP;\n        this.cPos1 = cP1;\n        this.cPos2 = cP2;\n        this.endPos = endP;\n\n        this.lenght = this.getBezierLen();\n    }\n\n    /**\n     * 每隔len个像素生成一个点,曲线开始的端点不生成点\n     * @param len \n     */\n    createPosArray(len: number) {\n        let fn: number = Math.floor(this.lenght / len);\n        let i: number = 1 / fn;\n        for (let t = i; t <= 1; t += i) {\n            let x: number = this.bezier(this.startPos.x, this.cPos1.x, this.cPos2.x, this.endPos.x, t);\n            let y: number = this.bezier(this.startPos.y, this.cPos1.y, this.cPos2.y, this.endPos.y, t);\n            this.posArray.push(cc.v2(x, y));\n        }\n        if (this.posArray.length < fn) { //补上结束端点\n            this.posArray.push(this.endPos);\n        }\n    }\n\n    /**\n     * 获得曲线长度\n     * @param f 将一段曲线分为多少份来求长度,默认20\n     */\n    private getBezierLen(f: number = 20): number {\n        let t: number = 1 / 20;\n        let l: number = 0;\n        let i: number;\n        let cP: cc.Vec2;\n        let lastP: cc.Vec2 = cc.v2(0, 0);\n        for (i = 0; i <= 1; i += t) {\n            let x: number = this.bezier(this.startPos.x, this.cPos1.x, this.cPos2.x, this.endPos.x, i);\n            let y: number = this.bezier(this.startPos.y, this.cPos1.y, this.cPos2.y, this.endPos.y, i);\n            cP = cc.v2(x, y);\n            l += (cP.sub(lastP)).mag();\n            lastP = cP;\n        }\n        return l;\n    }\n\n    private bezier(v1: number, v2: number, v3: number, v4: number, t: number): number {\n        return v1 * Math.pow(1 - t, 3) + 3 * v2 * t * Math.pow(1 - t, 2) + 3 * v3 * t * t * (1 - t) + v4 * Math.pow(t, 3);\n    }\n}\n\n@ccclass\nexport default class AnimationPath extends cc.Component {\n\n\n    private animation: cc.Animation = null;\n    private griphics: cc.Graphics = null;\n    onLoad() {\n        this.animation = this.node.getComponent(cc.Animation);\n    }\n\n    start() {\n        // this.drawPath(this.getNodePath(\"road1\"));\n        // this.drawPath(this.getNodePath(\"road2\"));\n        // this.drawPath(this.getNodePath(\"road3\"));\n    }\n\n    /**\n     * Gets world path\n     * @param pathName \n     * @returns world path \n     */\n    getWorldPath(pathName: string): cc.Vec2[] {\n        let path = this.getNodePath(pathName);\n        for (let i = 0; i < path.length; i++)\n            path[i] = this.node.convertToWorldSpaceAR(path[i]);\n        return path;\n    }\n\n    /**\n     * @param pathName \n     * @returns 节点坐标\n     */\n    private getNodePath(pathName: string): cc.Vec2[] {\n        let clips: cc.AnimationClip[] = this.animation.getClips();\n        let clip: cc.AnimationClip = clips[0];\n        let paths = clip.curveData.paths; //动画路径数组\n        let frameArray = paths[pathName].props.position; //关键帧数组即为一条路径            \n        let bezierPartArray: BezierPart[] = this.getBezierPartArray(frameArray);\n        let path: cc.Vec2[] = this._getPath(bezierPartArray);\n\n        return path;\n    }\n\n    /**\n     * 得到点路径\n     * @param bezierPartArray 曲线数组 \n     * @returns path 不含路径起点坐标\n     */\n    private _getPath(bezierPartArray: BezierPart[]): cc.Vec2[] {\n        let pArray: cc.Vec2[] = [];\n        let bezier: BezierPart;\n        for (let i = 0; i < bezierPartArray.length; i++) {\n            bezier = bezierPartArray[i];\n            bezier.createPosArray(16);\n            pArray = pArray.concat(bezier.posArray);\n\n        }\n        return pArray;\n    }\n\n    /**\n     * 由关键帧数组 得到 曲线段数组\n     * @param frameArray 关键帧数组\n     */\n    private getBezierPartArray(frameArray): BezierPart[] {\n        let bezierPartArray: BezierPart[] = [];\n\n        //两个关键帧组成一条路径\n        for (let j = 0; j < frameArray.length - 1; j++) {\n            let arr: BezierPart[] = this.createBezierPartArray(frameArray[j], frameArray[j + 1]);\n            bezierPartArray = bezierPartArray.concat(arr);\n        }\n\n        return bezierPartArray;\n    }\n\n    /**\n     * 由两个关键帧 生成 它们构成的贝塞尔曲线段数组\n     * @param startKeyFrame 开始关键帧\n     * @param endKeyFrame 结束关键帧\n     */\n    private createBezierPartArray(startKeyFrame, endKeyFrame): BezierPart[] {\n        let bezierPartArray: BezierPart[] = [];\n        let startP: cc.Vec2, cP1: cc.Vec2, cP2: cc.Vec2, endP: cc.Vec2;\n        let motionPath = startKeyFrame.motionPath; //移动路径数组即主控制点数组\n        let moPathSP, moPathEP; //一段曲线上的首尾端主控制点\n\n        //第一段\n        startP = cc.v2(startKeyFrame.value[0], startKeyFrame.value[1]);\n        moPathEP = motionPath[0];\n        cP1 = cP2 = cc.v2(moPathEP[2], moPathEP[3]);\n        endP = cc.v2(moPathEP[0], moPathEP[1]);\n        bezierPartArray.push(new BezierPart(startP, cP1, cP2, endP));\n\n        for (let i = 0; i < motionPath.length - 1; i++) { //0 - len - 1, len - 3 len - 2 len -1\n            moPathSP = motionPath[i];\n            moPathEP = motionPath[i + 1]\n            startP = cc.v2(moPathSP[0], moPathSP[1]);\n            cP1 = cc.v2(moPathSP[4], moPathSP[5]);\n            cP2 = cc.v2(moPathEP[2], moPathEP[3]);\n            endP = cc.v2(moPathEP[0], moPathEP[1]);\n            bezierPartArray.push(new BezierPart(startP, cP1, cP2, endP));\n        }\n\n        //最后一段\n        moPathSP = motionPath[motionPath.length - 1];\n        startP = cc.v2(moPathSP[0], moPathSP[1]);\n        cP1 = cP2 = cc.v2(moPathSP[4], moPathSP[5]);\n        endP = cc.v2(endKeyFrame.value[0], endKeyFrame.value[1]);\n        bezierPartArray.push(new BezierPart(startP, cP1, cP2, endP));\n\n        return bezierPartArray;\n    }\n\n    private drawPath(pointArray: cc.Vec2[]) {\n        this.griphics.moveTo(pointArray[0].x, pointArray[0].y);\n        for (let i = 1; i < pointArray.length; i++)\n            this.griphics.lineTo(pointArray[i].x, pointArray[i].y);\n\n        this.griphics.stroke();\n    }\n\n    /**\n     * 画出曲线的控制点\n     * @param bezierPartArray 曲线数组\n     */\n    private drawContrlPoint(bezierPartArray: BezierPart[]) {\n        for (let i = 0; i < bezierPartArray.length; i++) {\n            this.drawPoint(bezierPartArray[i].startPos);\n            this.drawPoint(bezierPartArray[i].cPos1, cc.Color.BLUE);\n            this.drawPoint(bezierPartArray[i].cPos2, cc.Color.BLUE);\n            this.drawPoint(bezierPartArray[i].endPos);\n        }\n    }\n\n    /**\n     * Draws point\n     * @param point 点坐标 \n     * @param color 默认颜色为红色\n     */\n    private drawPoint(point: cc.Vec2 | cc.Vec2[], color: cc.Color = null) {\n        if (color === null)\n            this.griphics.strokeColor = cc.Color.RED;\n        else\n            this.griphics.strokeColor = color;\n\n        if ((<cc.Vec2[]>point).length) {\n            for (let i = 0; i < (<cc.Vec2[]>point).length; i++) {\n                this.griphics.circle(point[i].x, point[i].y, 2);\n                this.griphics.stroke();\n            }\n        }\n        else {\n            this.griphics.circle((<cc.Vec2>point).x, (<cc.Vec2>point).y, 2);\n            this.griphics.stroke();\n        }\n\n    }\n}\n"]}